
02_HSE.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .vectors      00000400  08000000  08000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000001a4  08000400  08000400  00010400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init         00000004  080005a4  080005a4  000105a4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .fini         00000004  080005a8  080005a8  000105a8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .bss          00000000  20000000  20000000  00000000  2**0
                  ALLOC
  5 .data         00000000  20000000  20000000  000105ac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ARM.attributes 00000030  00000000  00000000  000105ac  2**0
                  CONTENTS, READONLY
  7 .comment      00000053  00000000  00000000  000105dc  2**0
                  CONTENTS, READONLY
  8 .debug_info   00000299  00000000  00000000  0001062f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 000001fe  00000000  00000000  000108c8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_aranges 00000090  00000000  00000000  00010ac6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_ranges 00000050  00000000  00000000  00010b56  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_macro  00000e7e  00000000  00000000  00010ba6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_line   000002f3  00000000  00000000  00011a24  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_str    00003e4b  00000000  00000000  00011d17  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_frame  000000f4  00000000  00000000  00015b64  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000400 <GpioInit>:
#include <stm32g431.h>


void GpioInit(void)
{
 8000400:	b480      	push	{r7}
 8000402:	af00      	add	r7, sp, #0
	SET_BIT(RCC_AHB2ENR, RCC_AHB2ENR_GPIOBEN);    // Подать тактовый сигнал на модуль GPIOA
 8000404:	4b0d      	ldr	r3, [pc, #52]	; (800043c <GpioInit+0x3c>)
 8000406:	681b      	ldr	r3, [r3, #0]
 8000408:	4a0c      	ldr	r2, [pc, #48]	; (800043c <GpioInit+0x3c>)
 800040a:	f043 0302 	orr.w	r3, r3, #2
 800040e:	6013      	str	r3, [r2, #0]
	MODIFY_REG(GPIOB_MODER,  GPIO_MODER_MODE8, 1<<GPIO_MODER_MODE8_Pos); //Включить PIN8 на вывод (светодиод LD2)
 8000410:	4b0b      	ldr	r3, [pc, #44]	; (8000440 <GpioInit+0x40>)
 8000412:	681b      	ldr	r3, [r3, #0]
 8000414:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8000418:	4a09      	ldr	r2, [pc, #36]	; (8000440 <GpioInit+0x40>)
 800041a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800041e:	6013      	str	r3, [r2, #0]
	MODIFY_REG(GPIOB_MODER,  GPIO_MODER_MODE7, 1<<GPIO_MODER_MODE7_Pos); //Включить PIN7 на вывод
 8000420:	4b07      	ldr	r3, [pc, #28]	; (8000440 <GpioInit+0x40>)
 8000422:	681b      	ldr	r3, [r3, #0]
 8000424:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8000428:	4a05      	ldr	r2, [pc, #20]	; (8000440 <GpioInit+0x40>)
 800042a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800042e:	6013      	str	r3, [r2, #0]
}
 8000430:	bf00      	nop
 8000432:	46bd      	mov	sp, r7
 8000434:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000438:	4770      	bx	lr
 800043a:	bf00      	nop
 800043c:	4002104c 	.word	0x4002104c
 8000440:	48000400 	.word	0x48000400

08000444 <main>:
#include <stm32g431.h>

void GpioInit(void);

int main(void)
{
 8000444:	b580      	push	{r7, lr}
 8000446:	b082      	sub	sp, #8
 8000448:	af00      	add	r7, sp, #0
		
	GpioInit();	//Настройка линий PB7 и PB8 на вывод
 800044a:	f7ff ffd9 	bl	8000400 <GpioInit>

	while(1)
	{
		uint32_t i=1000000;				      //Количество итераций в цикле задержки
 800044e:	4b0b      	ldr	r3, [pc, #44]	; (800047c <main+0x38>)
 8000450:	607b      	str	r3, [r7, #4]
		while(i)i--; 						  //Задержка
 8000452:	e002      	b.n	800045a <main+0x16>
 8000454:	687b      	ldr	r3, [r7, #4]
 8000456:	3b01      	subs	r3, #1
 8000458:	607b      	str	r3, [r7, #4]
 800045a:	687b      	ldr	r3, [r7, #4]
 800045c:	2b00      	cmp	r3, #0
 800045e:	d1f9      	bne.n	8000454 <main+0x10>
		INVERT_BIT(GPIOB_ODR, GPIO_ODR_OD8);  //Инвертировать LD2 (PB8)
 8000460:	4b07      	ldr	r3, [pc, #28]	; (8000480 <main+0x3c>)
 8000462:	681b      	ldr	r3, [r3, #0]
 8000464:	4a06      	ldr	r2, [pc, #24]	; (8000480 <main+0x3c>)
 8000466:	f483 7380 	eor.w	r3, r3, #256	; 0x100
 800046a:	6013      	str	r3, [r2, #0]
		INVERT_BIT(GPIOB_ODR, GPIO_ODR_OD7);  //Инвертировать (PB7)
 800046c:	4b04      	ldr	r3, [pc, #16]	; (8000480 <main+0x3c>)
 800046e:	681b      	ldr	r3, [r3, #0]
 8000470:	4a03      	ldr	r2, [pc, #12]	; (8000480 <main+0x3c>)
 8000472:	f083 0380 	eor.w	r3, r3, #128	; 0x80
 8000476:	6013      	str	r3, [r2, #0]
	{
 8000478:	e7e9      	b.n	800044e <main+0xa>
 800047a:	bf00      	nop
 800047c:	000f4240 	.word	0x000f4240
 8000480:	48000414 	.word	0x48000414

08000484 <start_up>:
int main(void);
void SystemClock_Config(void);

/* Точка входа  */
void start_up(void)
{
 8000484:	b580      	push	{r7, lr}
 8000486:	b082      	sub	sp, #8
 8000488:	af00      	add	r7, sp, #0
	uint32_t *src, *dst;

	/* Копирование данных секции .data из FLASH в RAM */
	src = &_sdata_flash;
 800048a:	4b12      	ldr	r3, [pc, #72]	; (80004d4 <start_up+0x50>)
 800048c:	607b      	str	r3, [r7, #4]
	dst = &_sdata_ram;
 800048e:	4b12      	ldr	r3, [pc, #72]	; (80004d8 <start_up+0x54>)
 8000490:	603b      	str	r3, [r7, #0]
	while (dst < &_edata_ram) {
 8000492:	e007      	b.n	80004a4 <start_up+0x20>
		*dst++ = *src++;
 8000494:	687a      	ldr	r2, [r7, #4]
 8000496:	1d13      	adds	r3, r2, #4
 8000498:	607b      	str	r3, [r7, #4]
 800049a:	683b      	ldr	r3, [r7, #0]
 800049c:	1d19      	adds	r1, r3, #4
 800049e:	6039      	str	r1, [r7, #0]
 80004a0:	6812      	ldr	r2, [r2, #0]
 80004a2:	601a      	str	r2, [r3, #0]
	while (dst < &_edata_ram) {
 80004a4:	683b      	ldr	r3, [r7, #0]
 80004a6:	4a0d      	ldr	r2, [pc, #52]	; (80004dc <start_up+0x58>)
 80004a8:	4293      	cmp	r3, r2
 80004aa:	d3f3      	bcc.n	8000494 <start_up+0x10>
	}

	/* Запись нулей в область памяти секции .bss */
	dst = &_sbss;
 80004ac:	4b0c      	ldr	r3, [pc, #48]	; (80004e0 <start_up+0x5c>)
 80004ae:	603b      	str	r3, [r7, #0]
	while (dst < &_ebss) {
 80004b0:	e004      	b.n	80004bc <start_up+0x38>
		*dst++ = 0;
 80004b2:	683b      	ldr	r3, [r7, #0]
 80004b4:	1d1a      	adds	r2, r3, #4
 80004b6:	603a      	str	r2, [r7, #0]
 80004b8:	2200      	movs	r2, #0
 80004ba:	601a      	str	r2, [r3, #0]
	while (dst < &_ebss) {
 80004bc:	683b      	ldr	r3, [r7, #0]
 80004be:	4a09      	ldr	r2, [pc, #36]	; (80004e4 <start_up+0x60>)
 80004c0:	4293      	cmp	r3, r2
 80004c2:	d3f6      	bcc.n	80004b2 <start_up+0x2e>
	}

	SystemClock_Config();
 80004c4:	f000 f810 	bl	80004e8 <SystemClock_Config>

	main();
 80004c8:	f7ff ffbc 	bl	8000444 <main>
}
 80004cc:	bf00      	nop
 80004ce:	3708      	adds	r7, #8
 80004d0:	46bd      	mov	sp, r7
 80004d2:	bd80      	pop	{r7, pc}
 80004d4:	080005ac 	.word	0x080005ac
 80004d8:	20000000 	.word	0x20000000
 80004dc:	20000000 	.word	0x20000000
 80004e0:	20000000 	.word	0x20000000
 80004e4:	20000000 	.word	0x20000000

080004e8 <SystemClock_Config>:


void SystemClock_Config(void)
{
 80004e8:	b480      	push	{r7}
 80004ea:	af00      	add	r7, sp, #0

  //Включить режим повышения выходного напряжения  главного регулятора до 1,28 вольт
  CLEAR_BIT(PWR_CR5, PWR_CR5_R1MODE);
 80004ec:	4b23      	ldr	r3, [pc, #140]	; (800057c <SystemClock_Config+0x94>)
 80004ee:	681b      	ldr	r3, [r3, #0]
 80004f0:	4a22      	ldr	r2, [pc, #136]	; (800057c <SystemClock_Config+0x94>)
 80004f2:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80004f6:	6013      	str	r3, [r2, #0]

  //Установка задержки чтения FLASH памяти до 4-х тактов
  FLASH_ACR=FLASH_ACR_DBG_SWEN  | FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_LATENCY_4WS ;
 80004f8:	4b21      	ldr	r3, [pc, #132]	; (8000580 <SystemClock_Config+0x98>)
 80004fa:	4a22      	ldr	r2, [pc, #136]	; (8000584 <SystemClock_Config+0x9c>)
 80004fc:	601a      	str	r2, [r3, #0]
  while((FLASH_ACR & 0xf) != FLASH_ACR_LATENCY_4WS );
 80004fe:	bf00      	nop
 8000500:	4b1f      	ldr	r3, [pc, #124]	; (8000580 <SystemClock_Config+0x98>)
 8000502:	681b      	ldr	r3, [r3, #0]
 8000504:	f003 030f 	and.w	r3, r3, #15
 8000508:	2b04      	cmp	r3, #4
 800050a:	d1f9      	bne.n	8000500 <SystemClock_Config+0x18>

  //Подключение внешнего кварцевого резонатора (HSE ON)
  SET_BIT(RCC_CR, RCC_CR_HSEON);
 800050c:	4b1e      	ldr	r3, [pc, #120]	; (8000588 <SystemClock_Config+0xa0>)
 800050e:	681b      	ldr	r3, [r3, #0]
 8000510:	4a1d      	ldr	r2, [pc, #116]	; (8000588 <SystemClock_Config+0xa0>)
 8000512:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000516:	6013      	str	r3, [r2, #0]
  while(READ_BIT(RCC_CR, RCC_CR_HSERDY) != (RCC_CR_HSERDY));
 8000518:	bf00      	nop
 800051a:	4b1b      	ldr	r3, [pc, #108]	; (8000588 <SystemClock_Config+0xa0>)
 800051c:	681b      	ldr	r3, [r3, #0]
 800051e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8000522:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8000526:	d1f8      	bne.n	800051a <SystemClock_Config+0x32>

  //Настройка PLL, используемого для SYSCLK домена
  //PLLM=6 (значение поля 5), PLLN=85 (значение поля 85), PLLR=2 (значение поля 0)
  MODIFY_REG(RCC_PLLCFGR, RCC_PLLCFGR_PLLSRC     | RCC_PLLCFGR_PLLM         | RCC_PLLCFGR_PLLN             | RCC_PLLCFGR_PLLR,
 8000528:	4b18      	ldr	r3, [pc, #96]	; (800058c <SystemClock_Config+0xa4>)
 800052a:	681a      	ldr	r2, [r3, #0]
 800052c:	4b18      	ldr	r3, [pc, #96]	; (8000590 <SystemClock_Config+0xa8>)
 800052e:	4013      	ands	r3, r2
 8000530:	4a16      	ldr	r2, [pc, #88]	; (800058c <SystemClock_Config+0xa4>)
 8000532:	f443 43aa 	orr.w	r3, r3, #21760	; 0x5500
 8000536:	f043 0353 	orr.w	r3, r3, #83	; 0x53
 800053a:	6013      	str	r3, [r2, #0]
		                  RCC_PLLCFGR_PLLSRC_HSE | 5 <<RCC_PLLCFGR_PLLM_Pos | (85 << RCC_PLLCFGR_PLLN_Pos) | 0<<RCC_PLLCFGR_PLLR_Pos);

  //Включение PLL
  SET_BIT(RCC_CR, RCC_CR_PLLON);
 800053c:	4b12      	ldr	r3, [pc, #72]	; (8000588 <SystemClock_Config+0xa0>)
 800053e:	681b      	ldr	r3, [r3, #0]
 8000540:	4a11      	ldr	r2, [pc, #68]	; (8000588 <SystemClock_Config+0xa0>)
 8000542:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000546:	6013      	str	r3, [r2, #0]
  while(READ_BIT(RCC_CR, RCC_CR_PLLRDY) != (RCC_CR_PLLRDY));
 8000548:	bf00      	nop
 800054a:	4b0f      	ldr	r3, [pc, #60]	; (8000588 <SystemClock_Config+0xa0>)
 800054c:	681b      	ldr	r3, [r3, #0]
 800054e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8000552:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8000556:	d1f8      	bne.n	800054a <SystemClock_Config+0x62>

  //Включение выхода PLL, используемого для  SYSCLK
  SET_BIT(RCC_PLLCFGR, RCC_PLLCFGR_PLLREN);
 8000558:	4b0c      	ldr	r3, [pc, #48]	; (800058c <SystemClock_Config+0xa4>)
 800055a:	681b      	ldr	r3, [r3, #0]
 800055c:	4a0b      	ldr	r2, [pc, #44]	; (800058c <SystemClock_Config+0xa4>)
 800055e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000562:	6013      	str	r3, [r2, #0]

  //Подключение выхода PLL в качестве источника  SYSCLK
  MODIFY_REG(RCC_CFGR, RCC_CFGR_SW, RCC_CFGR_SW_PLL);
 8000564:	4b0b      	ldr	r3, [pc, #44]	; (8000594 <SystemClock_Config+0xac>)
 8000566:	681b      	ldr	r3, [r3, #0]
 8000568:	4a0a      	ldr	r2, [pc, #40]	; (8000594 <SystemClock_Config+0xac>)
 800056a:	f043 0303 	orr.w	r3, r3, #3
 800056e:	6013      	str	r3, [r2, #0]

}
 8000570:	bf00      	nop
 8000572:	46bd      	mov	sp, r7
 8000574:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000578:	4770      	bx	lr
 800057a:	bf00      	nop
 800057c:	40007080 	.word	0x40007080
 8000580:	40022000 	.word	0x40022000
 8000584:	00040604 	.word	0x00040604
 8000588:	40021000 	.word	0x40021000
 800058c:	4002100c 	.word	0x4002100c
 8000590:	f9ff800c 	.word	0xf9ff800c
 8000594:	40021008 	.word	0x40021008

08000598 <nmi_handler>:
};


/* Обработчик немаскируемого прерывания  */
void nmi_handler(void)
{
 8000598:	b480      	push	{r7}
 800059a:	af00      	add	r7, sp, #0
	for (;;);
 800059c:	e7fe      	b.n	800059c <nmi_handler+0x4>

0800059e <hardfault_handler>:
}

/* Обработчик прерывания аппаратной ошибки */
void hardfault_handler(void)
{
 800059e:	b480      	push	{r7}
 80005a0:	af00      	add	r7, sp, #0
	for (;;);
 80005a2:	e7fe      	b.n	80005a2 <hardfault_handler+0x4>

Disassembly of section .init:

080005a4 <_init>:
 80005a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80005a6:	bf00      	nop

Disassembly of section .fini:

080005a8 <_fini>:
 80005a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80005aa:	bf00      	nop
