#include <stm32g431.h>
#include <math.h>

#define FD   1000 //Частота дискретизации KHz
#define FLPF 1    //Частота перегиба ФНЧ KHz
extern float R;	  //Параметр фильтра, зависящий от частоты

//Вход ADC1 на PA0
void ADC1_init()
{

    //Настройка тактирования ADC
	SET_BIT(RCC_CCIPR,   1 << 29 );       // Выбрать системный clock в качестве тактового сигнала для ADC
    SET_BIT(RCC_AHB2ENR, 1 << 13 );       // Подать тактовый сигнал на модуль ADC12
    SET_BIT(ADC12_COMMON_CCR, 2 << 16 );  // Выбрать в качестве тактового сигнала   adc_hclk/2

    //Настройка режима ADC
    ADC1_CR = 0;             			  // Сброс всех бит в ADC1_CR (ADEN = 0 для обеспечения конфигурирования)
    SET_BIT(ADC1_CR, 1 << 28);            // Включить  опорное напряжение ADC
    // Запуск преобразования от  TIM2_TRG0 (канал 11)(биты 5- 11), перезапись разрешена (бит 12)
    ADC1_CFGR = (1 << 12)+(1 << 10)+ (11 << 5);
	ADC1_SQR1 = (1 << 6);  				  // Выбрать входной канал 1 (PA0)
//	ADC1_DIFSEL = 2;					  // ADC1 канал 1 в дифференциальном режиме

	//Настройка прерывания
	ADC1_IER = (1 << 3);       			  // Разрешить прерывание по окончанию преобразования в ADC
	SET_BIT(NVIC_ISER0, (1 << 18));		  // Разрешить в NVIC прерывание #18 (ADC1)

	/* Установка приоритета n.
	   Приоритеты задаются в регистрах NVIC_IPRXX (по четыре устройства на регистр см. док.),
	   Записывается значение n*16 (n 0-15), чем больше значение тем ниже приоритет.
	   По умолчанию у всех прерываний максимальный приоритет = 0.
	*/

	NVIC_IPR4 = 0x00100000;				  //Установка приоритета  16 для прерывания 18.

	SET_BIT(ADC1_CR, (1 << 0) | (1 << 2));// Включить ADC1 и начать преобразование
	SET_BIT(TIM2_CR1, TIM_CR1_CEN);       //Запуск TIM2 - cтарт генерации сигнала дискретизации для ADC1


}


void ADC1_IRQHandler(void)
{

	//Параметр, определяющий полосу пропускания фильтра dF
	//L  ≈  5.6 * Fd/FD
	static float L = 0.01;

	//Начальные значения переменных фильтра
	static float X = 0;
	static float V = 0;

	//Параметр интегрирующей цепочки
	static float K = 2*M_PI*FLPF/FD; //K = 2PI*f/fd
	//Начальные значения переменных детектора
	static float U = 0;
	float D;
	int out;

	//Смещение для ADC и DAC
	static int	 S_ADC = 1910; // Uдел/3.3 * 4096  -> 1.54/3.3 *4096 = 1910
	static int	 S_DAC = 100;

	// Сброс флага переполнения в ADC1
	SET_BIT(ADC1_ISR, (1 << 3));

	//Фильтр
	X += (int)ADC1_DR- S_ADC;
	V -= X * R;
	X += V - X * L;

	//Детектор
	D = fabs(X);
	U += (D - U) * K; // Интегрирующая цепь ЗЧ
	out = U + S_DAC;

	// Ограничитель, предотвращает переполнение DAC при сильном сигнале
	if( out > 4000) out = 4000;

	//Запись в DAC
	DAC1_DHR12R1 = out;

}

