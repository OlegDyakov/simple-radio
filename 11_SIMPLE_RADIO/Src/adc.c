#include <stm32g431.h>
#include <math.h>

#define FD   700   //Частота дискретизации KHz
#define FLPF 2      //Частота перегиба ФНЧ KHz
#define FAGC 0.001  //Частота перегиба АРУ KHz
float 	R;	  	    //Параметр фильтра, зависящий от frequency


//Таймер, задающий частоту дискретизации ADC1
void TIM2_Init(void)
{

  SET_BIT(RCC_APB1ENR1, RCC_APB1ENR1_TIM2EN); // Подаем на TIM2 тактовую частоту
  TIM2_ARR = 170000/FD - 1;         		  // Загружаем Auto-reload register  f = 170 000 000/(TIM2_ARR+1), 1 MHz -> 170 -1
  TIM2_CR2 = TIM_CR2_MMS_1;   				  // Выбор мастер режима таймера для возможности тактирования ADC

}

//Вход ADC1 на PA0
void ADC1_init()
{

    //Настройка тактирования ADC
	SET_BIT(RCC_CCIPR,   1 << 29 );       // Выбрать системный clock в качестве тактового сигнала для ADC
    SET_BIT(RCC_AHB2ENR, 1 << 13 );       // Подать тактовый сигнал на модуль ADC12
    SET_BIT(ADC12_COMMON_CCR, 2 << 16 );  // Выбрать в качестве тактового сигнала   adc_hclk/2

    //Настройка режима ADC
    ADC1_CR = 0;             			  // Сброс всех бит в ADC1_CR (ADEN = 0 для обеспечения конфигурирования)
    SET_BIT(ADC1_CR, 1 << 28);            // Включить  опорное напряжение ADC

    // Запуск преобразования от  TIM2_TRG0 (канал 11)(биты 5- 11), перезапись разрешена (бит 12)
    ADC1_CFGR = (1 << 12)+(1 << 10)+ (11 << 5);
	ADC1_SQR1 = (1 << 6);  				  // Выбрать входной канал 1 (PA0)

	//Настройка прерывания
	ADC1_IER = (1 << 3);       			  // Разрешить прерывание по окончанию преобразования в ADC
	SET_BIT(NVIC_ISER0, (1 << 18));		  // Разрешить в NVIC прерывание #18 (ADC1)

    /* Установка приоритета n.
	  Приоритеты задаются в регистрах NVIC_IPRXX (по четыре устройства на регистр см. док.),
	  Записывается значение n*16 (n 0-15), чем больше значение тем ниже приоритет.
	  По умолчанию у всех прерываний максимальный приоритет = 0.
	*/

	NVIC_IPR4 = 0x00100000;				  //Установка приоритета  1 для прерывания 18.

	SET_BIT(ADC1_CR, (1 << 0) | (1 << 2));// Включить ADC1 и начать преобразование
	SET_BIT(TIM2_CR1, TIM_CR1_CEN);       //Запуск TIM2 - cтарт генерации сигнала дискретизации для ADC1

}

// Расчет параметра фильтра зависящего от частоты R=(2*Sin(PI*W))^2
void KHZ_to_R(int fr)
{
	R = (2*sin(M_PI*(0.996*fr)/FD));
	R *= R;
}

//Обработка отсчета от ADC1
void ADC1_IRQHandler(void)
{

	//Параметр, определяющий полосу пропускания фильтра dF
	//L  ≈  5.6 * Fd/FD
	static float L = 0.005;

	//Начальные значения переменных фильтра
	static float X = 0;
	static float V = 0;

	//Параметр интегрирующей цепочки
	static float K1 = 2*M_PI*FLPF/FD; //ФНЧ K = 2PI*f/fd
	static float K2 = 2*M_PI*FAGC/FD; //АРУ

	//Начальные значения переменных детектора
	static float U1 = 0;
	static float U2 = 0;
	static float AGCT  = 1000;

	//Смещение для ADC и DAC
	static int	 S_ADC = 1975; // Uдел/3.3 * 4096  -> 1.586/3.29 *4096 = 1910
	static int	 S_DAC = 800;

	float D;
	int   OUT;

	// Сброс флага переполнения в ADC1
	SET_BIT(ADC1_ISR, (1 << 3));

	//Фильтр
	X += (int)ADC1_DR- S_ADC;
	V -= X * R;
	X += V - X * L;

	//Детектор
	D = fabs(X);
	U1  += (D - U1) * K1; // Интегрирующая цепь ФНЧ
	OUT = U1;

	//АРУ
	U2  += (D - U2) * K2; // Интегрирующая цепь АРУ
	if( U2 > AGCT)
		OUT = U1*(AGCT/U2);

	OUT +=  S_DAC;

	// Ограничитель, предотвращает переполнение DAC при сильном сигнале
	if( OUT > 4000) OUT = 4000;

	//Запись в DAC
	DAC1_DHR12R1 = OUT;

}

